1、IE9-不支持addEventListener
2、IE8-不支持localStorage 和 sessionStorage
3、IE8-不支持JSON对象
4、meta 标签的作用
  meta标签只有4个属性值，name、http-equiv、charset、content
  其中name、http-equiv是参数名
  content是参数值
  meta标签用于告诉浏览器一些有关页面的元信息

  charset是HTML5中的新属性，替换了
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  仍然允许使用http-equiv属性来规定字符集，但是使用新方法可以减少代码量
  若是charset和http-equiv同时出现，听charset的，若没有charset属性才听http-equiv的
  在服务器下，模板或服务器会自定义header头，此时定义在页面上的http-equiv可能不起作用了。

  http-equiv的值：
    content-type
    expires
    refresh
    set-cookie

  name的值：
    author
    description
    keywords
    generator
    revised
    others
  
  charset的值：
    各种编码
 在文档中一定要指定charset或http-equiv的值为一个编码，否则的话可能会出现乱码，比如chrome，若文档没有指定编码的话会默认以GBK打开（当然不同浏览器，不同国家这个默认值肯定是不一样的），
 若你的html文件编码格式是utf-8的话，就会出现乱码了！

 乱码出现的本质原因：解码字符集与编码字符集不一致
 一个html文档的编码如果是utf-8的话，传输过来的就是以utf-8编码的二进制流，在浏览器端，也要以utf-8来解码这个二进制流，否则会出现乱码

4、一个jsonp请求：
 $.ajax({
    url: "http://s.diaox2.com/ddsearch/q",
    dataType: 'jsonp',
    jsonp: 'cb',
    jsonpCallback: "cb2",
    cache:true,// 防止 jquery 发送ajax请求时在后面带上时间戳，导致过不了cdn
    timeout: 20000,
    data: {
      data: JSON.stringify({
        "query": q,
        "from": "pc"
      })
    },
    // type:"POST",
    // dataType:"json",
    // contentType: 'application/json',//若是没有这个属性的话，就不会发送options请求
    // data:JSON.stringify({"query":q,"from":"pc"}),
    error: function(e) {
      console.log("搜索接口的jsonp执行失败！！" + " " + e);
    },
    success: normalSearchSuccess
});
5、前端渲染和后端渲染
 前端渲染：
  使用ajax调用后端的接口，后端返回json数据，这个json数据可能是元数据，也可能是带有html标签的数据，
  然后通过js的dom api插入到页面上，叫做前端渲染
 后端渲染：
  浏览器直接接收到经过服务器计算之后的呈现给用户的最终HTML字符串，这里的计算就是服务器经过解析存放在服务器端的模板
  文件（asp、aspx、php、jsp、tpl、ejs、jade）来完成的（或者直接response.write('<html>...</html>')）,
  这种情况下浏览器直接解析html，然后渲染显示在屏幕上
 
 前后端的本质区别就一点：
  把数据经过解析，生成了html字符串，是谁来完成的？前端完成就是前端渲染，后端完成就是后端渲染

6、js的执行确实会阻塞GUI渲染线程，在做调调PC站的礼物功能时，上面的关键字点击变红，再次点击就取消变红（active），取消变红的时候并不是马上取消了，因为要执行大段的js，导致浏览器的GUI渲染线程没有时间把他取消变红
  解决办法是：
  给dom操作的函数
  setTimeout(function(){
    renderDOMByIntersect();
  },1000)
  这样点击、再点击就能流畅的切换active状态了。
  但这会延迟dom操作，并不是最好的解决办法。

7、ID选择器
   一个页面，每个标签只能有一个id属性，若是有多个的话，只算第一个，每个标签的id属性的值不能重复，重复的话也只算第一个
   例如：
   <p id="d">p</p>
   <h1 id="d">h1</h1>
   <div id="div1" id="div2"></div>
   
   css :
   1、
    #d{
      width:100px;
      height:100px;
      border:1px blue solid;
     }
   2、
    #div1{ 
      width:100px;
      height:100px;
      border:1px red solid;
     }
     #div2{
      width:100px;
      height:100px;
      border:1px green solid;
     }
     只有#div1起作用


   会命中 p 和 h1（不知道为什么？）
   js：
   1、 
   var oD = document.getElementById('d');
   只会命中p

   2、
   var oDiv1 = document.getElementById('div1'); // 命中！
   var oDiv2 = document.getElementById('div2'); // null






